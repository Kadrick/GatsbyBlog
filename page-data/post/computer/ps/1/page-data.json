{"componentChunkName":"component---src-layout-post-tsx-content-file-path-src-posts-computer-ps-1-index-mdx","path":"/post/computer/ps/1/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://kadrick.github.io/GatsbyBlog"}},"mdx":{"body":"\n## 문제집\n\n한국정보올림피아드 시.도 지역본선 2005 - [https://www.acmicpc.net/category/72](https://www.acmicpc.net/category/72)\n\n### 초등부\n\n---\n\n#### 1. 대표값2 - 2587\n\n구현\n\n#### 2. 곱셈 - 2588\n\n이것도 구현\n\n#### 3. 보물섬 - 2589\n\nBFS\n\n#### 4. 색종이 - 2590\n\n조건 분기 - 크기가 큰 종이부터 차례대로 넣고 남는 공간에 크기가 작은 종이를 넣을 수 있는지 계산했다.\n\n#### 5. 숫자카드 - 2591\n\n카드로 바꿀 수 있는 수가 34 이하인 것을 주의하자.\n\n<CH.Code>\n\n```cpp 2587.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint main(void) {\n  fastio;\n\n  int sum = 0;\n  vector<int> arr;\n  for (int i = 0; i < 5; i++) {\n    int t;\n    cin >> t;\n    sum += t;\n    arr.push_back(t);\n  }\n\n  cout << sum / 5 << endl;\n  sort(arr.begin(), arr.end());\n  cout << arr[2] << endl;\n\n  return 0;\n}\n```\n\n```py 2588.py\nn1 = int(input())\nn2 = list(map(int, list(str(input()))))\nresult = 0\n\nfor i in range(3):\n    print(n1 * n2[2-i])\n    result += n1 * n2[2-i] * (10**i)\n\nprint(result)\n```\n\n```cpp 2589.cpp\n#include <bits/stdc++.h>\n#define FastIO ios::sync_with_stdio(false);\n#define endl    '\\n'\nusing namespace std;\n\nint height, width, ans = 0;\nint dy[4] = {1,0,-1,0};\nint dx[4] = {0,1,0,-1};\nvector<vector<char>> board;\nvector<vector<int>> mask;\n\nvoid init()\n{\n    mask.clear();\n    mask.resize(height, vector<int> (width, 0));\n}\n\nvoid search(pair<int,int> pos)\n{\n    queue<pair<int, int>> q;\n    q.push(pos);\n    mask[pos.first][pos.second] = 1;\n    while (!q.empty())\n    {\n        pair<int, int> cur = q.front();\n        q.pop();\n        ans = max(mask[cur.first][cur.second], ans);\n\n        for (int i = 0; i < 4; i++)\n        {\n            int ny = cur.first + dy[i];\n            int nx = cur.second + dx[i];\n            \n            if(ny < 0 || ny >= height || nx < 0 || nx >= width || board[ny][nx] == 'W' || mask[ny][nx]) continue;\n\n            q.push(make_pair(ny, nx));\n            mask[ny][nx] = mask[cur.first][cur.second] + 1;\n        }\n    }\n    \n\n}\n\nvoid solve()\n{\n    cin >> height >> width;\n    board.resize(height, vector<char> (width));\n    init();\n\n    for (int i = 0; i < height; i++)\n    {\n        for (int j = 0; j < width; j++)\n            cin >> board[i][j];\n    }\n\n    for (int i = 0; i < height; i++)\n    {\n        for (int j = 0; j < width; j++)\n        {\n            if(board[i][j] == 'L')\n            {\n                search(make_pair(i, j));\n                init();\n            }\n        }\n        \n    }\n    \n    cout << ans - 1 << endl;\n}\n\nint main () \n{\n    FastIO;\n\n    solve();\n\n    return 0;\n}\n```\n\n```cpp 2590.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint main(void) {\n  fastio;\n\n  vector<int> cnt(7, 0);\n  for (int i = 0; i < 6; i++) {\n    cin >> cnt[i + 1];\n  }\n\n  int ans = cnt[6];\n\n  // 5 - 1\n  ans += cnt[5];\n  cnt[1] -= cnt[5] * 11;\n\n  // 4 - 2 - 1\n  ans += cnt[4];\n  cnt[2] -= cnt[4] * 5;\n  if (cnt[2] < 0) {\n    cnt[1] -= cnt[2] * -4;\n    cnt[2] = 0;\n  }\n\n  //  3 - 2 - 1\n  ans += cnt[3] / 4;\n  cnt[3] = cnt[3] % 4;\n  if (cnt[3] != 0) {\n    ans++;\n    int possible2 = (4 - cnt[3]) * 2 - 1;\n    int draw2 = min(cnt[2], possible2);\n    cnt[2] -= draw2;\n    cnt[1] -= 36 - draw2 * 4 - cnt[3] * 9;\n  }\n\n  // 2 - 1\n  if (cnt[2] > 0) {\n    ans += cnt[2] / 9;\n    cnt[2] = cnt[2] % 9;\n\n    if (cnt[2] != 0) {\n      ans++;\n      cnt[1] -= 36 - cnt[2] * 4;\n    }\n  }\n\n  // 1\n  if (cnt[1] > 0) {\n    ans += cnt[1] / 36;\n    if (cnt[1] % 36 != 0) {\n      ans++;\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}\n```\n\n```cpp 2591.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint solve(vector<int> &cache, string &s, int start) {\n\n  if (start >= s.length())\n    return 1;\n\n  if (s[start] == '0')\n    return 0;\n\n  if (cache[start] != -1)\n    return cache[start];\n\n  int ret = solve(cache, s, start + 1);\n\n  if (start + 1 < s.length()) {\n    int val = (s[start] - '0') * 10 + (s[start + 1] - '0');\n    if (0 < val && val <= 34) {\n      ret += solve(cache, s, start + 2);\n    }\n  }\n\n  cache[start] = ret;\n  return ret;\n}\n\nint main(void) {\n  fastio;\n\n  string s;\n  cin >> s;\n\n  vector<int> cache(s.length(), -1);\n\n  cout << solve(cache, s, 0);\n\n  return 0;\n}\n```\n\n</CH.Code>\n\n\n### 중등부\n\n---\n\n#### 1. 대표값 - 2592\n\n구현\n\n#### 2. 색종이 - 2590\n\n초등부 4번\n\n#### 3. 숫자카드 - 2591\n\n초등부 5번\n\n#### 4. 엘리베이터 - 2593\n\n각 층에서 사용할 수 있는 엘리베이터와 각 엘리베이터에서 이동할 수 있는 층을 이용해서 그래프 탐색을 했다.\n한번 사용한 엘리베이터는 다시 사용하지 않는 것을 생각하자.\n\n#### 5. 화물열차 - 1665\n\n구간의 개수는 적고, 구간의 범위는 넓어서 개수로 어떻게 처리가 안될까? 라는 생각만 가지고 끙끙대고 있었는데, [지나가던 행인이](https://github.com/skeep194) 답을 알려줬다. 좋았쓰!\n\n<br/>\n\n![고오맙다](./1665.png)\n\n<br/>\n\n<CH.Code>\n\n```cpp 2592.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint main(void) {\n  fastio;\n\n  int sum = 0;\n  vector<int> arr(101, 0);\n  for (int i = 0; i < 10; i++) {\n    int t;\n    cin >> t;\n    sum += t;\n    arr[t / 10]++;\n  }\n\n  cout << sum / 10 << endl;\n\n  int mx = -1, ans = -1;\n  for (int i = 0; i <= 100; i++) {\n    if (mx < arr[i]) {\n      ans = i;\n      mx = arr[i];\n    }\n  }\n\n  cout << ans * 10 << endl;\n\n  return 0;\n}\n```\n\n```cpp 2593.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint main(void) {\n  fastio;\n\n  int n, m;\n  cin >> n >> m;\n\n  vector<vector<int>> elevator(m + 1, vector<int>());\n  vector<vector<int>> floor(n + 1, vector<int>());\n\n  for (int i = 0; i < m; i++) {\n    int st, gap;\n    cin >> st >> gap;\n\n    for (int j = st; j <= n; j += gap) {\n      elevator[i + 1].push_back(j);\n      floor[j].push_back(i + 1);\n    }\n  }\n\n  int start, end;\n  cin >> start >> end;\n\n  queue<pair<int, pair<int, int>>> q;\n  vector<int> dist(n + 1, INT_MAX), visitedElev(m + 1, false);\n  vector<pair<int, int>> trace(n + 1, {-1, -1});\n  dist[start] = 0;\n  trace[start] = {-1, -1};\n  q.push({0, {start, -1}});\n\n  while (!q.empty()) {\n\n    auto [step, info] = q.front();\n    auto [cur, eleIdx] = info;\n    q.pop();\n\n    for (int elev : floor[cur]) {\n\n      if (visitedElev[elev]) {\n        continue;\n      }\n      visitedElev[elev] = true;\n\n      for (int nextFloor : elevator[elev]) {\n\n        if (dist[nextFloor] > step + 1) {\n\n          dist[nextFloor] = step + 1;\n          trace[nextFloor] = {cur, elev};\n\n          q.push({step + 1, {nextFloor, elev}});\n        }\n      }\n    }\n  }\n\n  if (dist[end] == INT_MAX) {\n    cout << -1 << endl;\n  } else {\n\n    cout << dist[end] << endl;\n\n    int cur = end;\n    vector<int> route;\n    while (cur != -1) {\n      route.push_back(trace[cur].second);\n      cur = trace[cur].first;\n    }\n\n    for (int i = dist[end] - 1; i >= 0; i--) {\n      cout << route[i] << endl;\n    }\n  }\n\n  return 0;\n}\n```\n\n```cpp 1665.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint main(void) {\n  fastio;\n\n  int n, m;\n  cin >> n;\n  vector<pair<long long, long long>> trainA, trainB;\n  for (int i = 0; i < n; i++) {\n    long long x, y;\n    cin >> x >> y;\n    trainA.push_back({x, y});\n  }\n\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    long long x, y;\n    cin >> x >> y;\n    trainB.push_back({x, y});\n  }\n\n  // moveCnt, flag;\n  vector<pair<long long, long long>> section;\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      // startA + startB : 구간 시작\n      section.push_back({trainA[i].first + trainB[j].first - 1, 1});\n\n      // startA + endB : 최대 구간 (더 이상 화물이 추가되지 않음)\n      section.push_back({trainA[i].first + trainB[j].second, -1});\n\n      // endA + startB : 감소 구간 시작 (trainB가 trainA를 지나치기 시작)\n      section.push_back({trainA[i].second + trainB[j].first, -1});\n\n      // endA + endB : 구간 끝\n      section.push_back({trainA[i].second + trainB[j].second + 1, 1});\n    }\n  }\n\n  sort(section.begin(), section.end());\n\n  // sweep\n  long long curPack = 0, curMove = 0, overlap = 0;\n  pair<long long, long long> ans = {0, 0};\n\n  for (auto [moveCnt, flag] : section) {\n    curPack += overlap * (moveCnt - curMove);\n    overlap += flag, curMove = moveCnt;\n    if (ans.first < curPack) {\n      ans = {curPack, curMove};\n    }\n  }\n\n  cout << ans.second - 1 << endl;\n\n  return 0;\n}\n```\n\n</CH.Code>\n\n### 고등부\n\n---\n\n#### 1. 대표값 - 2592\n\n중등부 1번 \n\n#### 2. 놀이공원 - 2594\n\n구현\n\n#### 3. 로봇 - 1726\n\nBFS인데, 방향바라보고 있는 방향을 주의해서 구현하자.\n\n#### 4. 화물열차 - 1665\n\n중등부 5번\n\n#### 5. 배수 - 2595\n\n1로만 이루어진 수를 $x$로 나눈다고 생각해보자.\n\n$$\n\\begin{align}\n1111111\\ \\%\\ x &= x_{1} \\\\\n11111111\\ \\%\\ x &= x_{2} \\\\\n111111111\\ \\%\\ x &= x_{3} \\\\\n\\vdots \\\\\n111111111\\dots\\ \\%\\ x &= x_{n}\n\\end{align} \n$$\n\n$x_{n} < x$이고, 1로 이루어진 수는 무한히 존재한다. \n\n여기서, 같은 나머지를 가지는 수 2개를 서로 빼면 \n$1111111111\\dots - 111111 = 11 \\dots 1111000000$ 이고, 2개의 숫자(1과 0)로 이루어진 $x$의 배수는 존재한다.\n\n<br />\n\n이 생각에 기초해서 2개의 숫자를 고르고, 그 숫자로 이루어지고 같은 나머지를 가진 2개의 수를 찾았다.\n\n<CH.Code>\n\n```cpp 2594.cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint strToMin(string t) {\n  int tt = stoi(t);\n  return (tt / 100 - 10) * 60 + tt % 100;\n}\n\nint main(void) {\n  fastio;\n\n  int n;\n  cin >> n;\n\n  vector<pair<int, int>> arr;\n  for (int i = 0; i < n; i++) {\n    string s, e;\n    cin >> s >> e;\n    arr.push_back({strToMin(s) - 10, strToMin(e) + 10});\n  }\n  arr.push_back({720, 100000});\n\n  sort(arr.begin(), arr.end(),\n       [](pair<int, int> left, pair<int, int> right) -> bool {\n         if (left.first == right.first) {\n           return left.second < right.second;\n         }\n         return left.first < right.first;\n       });\n\n  int s = 0, e = 0, t = 0, ans = 0;\n\n  for (int i = 0; i < n + 1; i++) {\n    s = arr[i].first;\n    e = arr[i].second;\n\n    if (s > t) {\n      ans = max(ans, s - t);\n    }\n    t = max(e, t);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n```\n\n```cpp 1726.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint main(void) {\n  fastio;\n\n  int height, width;\n  cin >> height >> width;\n\n  int dy[4] = {0, 1, 0, -1};\n  int dx[4] = {1, 0, -1, 0};\n\n  auto rotateRight = [](int dir) -> int { return (dir + 1) % 4; };\n\n  auto rotateLeft = [](int dir) -> int { return (dir + 4 - 1) % 4; };\n\n  auto changeDir = [](int dir) -> int {\n    if (dir == 1)\n      return 2;\n    if (dir == 2)\n      return 1;\n    return dir;\n  };\n\n  auto isInside = [&](int y, int x) -> bool {\n    return (0 <= y && y < height && 0 <= x && x < width);\n  };\n\n  vector<vector<bool>> board(height, vector<bool>(width, true));\n  vector<vector<vector<int>>> dist(\n      height, vector<vector<int>>(width, vector<int>(4, INT32_MAX)));\n\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      int t;\n      cin >> t;\n      board[i][j] = t == 1 ? true : false;\n    }\n  }\n\n  int sY, sX, sD, eY, eX, eD;\n  cin >> sY >> sX >> sD;\n  cin >> eY >> eX >> eD;\n\n  sD = changeDir(sD - 1);\n  eD = changeDir(eD - 1);\n\n  queue<tuple<int, int, int, int>> q;\n  q.push({0, sY - 1, sX - 1, sD});\n  dist[sY - 1][sX - 1][sD] = 0;\n\n  while (!q.empty()) {\n\n    auto [step, curY, curX, curD] = q.front();\n    q.pop();\n\n    if (step > dist[curY][curX][curD]) {\n      continue;\n    }\n\n    for (int k = 1; k <= 3; k++) {\n      int nY = dy[curD] * k + curY;\n      int nX = dx[curD] * k + curX;\n\n      if (!isInside(nY, nX)) {\n        break;\n      }\n      if (board[nY][nX]) {\n        break;\n      }\n\n      if (dist[nY][nX][curD] > step + 1) {\n        dist[nY][nX][curD] = step + 1;\n        q.push({step + 1, nY, nX, curD});\n      }\n    }\n\n    int right = rotateRight(curD);\n    if (dist[curY][curX][right] > step + 1) {\n      dist[curY][curX][right] = step + 1;\n      q.push({step + 1, curY, curX, right});\n    }\n\n    int left = rotateLeft(curD);\n    if (dist[curY][curX][left] > step + 1) {\n      dist[curY][curX][left] = step + 1;\n      q.push({step + 1, curY, curX, left});\n    }\n  }\n\n  cout << dist[eY - 1][eX - 1][eD] << endl;\n\n  return 0;\n}\n```\n\n```cpp 2595.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint main(void) {\n  fastio;\n\n  int n;\n  cin >> n;\n\n  vector<pair<int, string>> ans;\n\n  auto comp = [](string left, string right) -> bool {\n    if (left.length() == right.length()) {\n      for (int i = 0; i < left.length(); i++) {\n        if (left[i] == right[i])\n          continue;\n        return left[i] < right[i];\n      }\n    }\n    return left.length() < right.length();\n  };\n\n  for (int i = 0; i < 10; i++) {\n    for (int j = i; j < 10; j++) {\n      vector<bool> cache(n, false);\n\n      queue<pair<int, string>> q;\n      if (i) {\n        q.push({i % n, string(1, '0' + i)});\n        cache[i % n] = true;\n      }\n      if (j && i != j) {\n        q.push({j % n, string(1, '0' + j)});\n        cache[j % n] = true;\n      }\n\n      while (!q.empty()) {\n        auto [cur, str] = q.front();\n        q.pop();\n\n        if (cur == 0) {\n          ans.push_back({i == j, str});\n          break;\n        }\n\n        int next = 0;\n        // append i\n        next = (cur * 10 + i) % n;\n        if (!cache[next]) {\n          cache[next] = true;\n          q.push({next, str + string(1, '0' + i)});\n        }\n\n        // append j\n        next = (cur * 10 + j) % n;\n        if (!cache[next]) {\n          cache[next] = true;\n          q.push({next, str + string(1, '0' + j)});\n        }\n      }\n    }\n  }\n\n  sort(ans.begin(), ans.end(),\n       [&](pair<int, string> left, pair<int, string> right) -> bool {\n         if (left.first == right.first) {\n           return comp(left.second, right.second);\n         }\n\n         return left.first > right.first;\n       });\n\n  cout << ans[0].second << endl;\n\n  return 0;\n}\n```\n\n</CH.Code>\n","frontmatter":{"title":"PS Note #1","tags":["Problem Solving"],"description":"한국정보올림피아드 시.도 지역본선 2005","slug":"computer/ps/1","date":"2024-06-27"}}},"pageContext":{"id":"00614f9b-5e2f-5ec2-bc9e-0d3051d488e7","frontmatter":{"title":"PS Note #1","tags":["Problem Solving"],"date":"2024-06-27T00:00:00.000Z","description":"한국정보올림피아드 시.도 지역본선 2005","slug":"computer/ps/1"}}},"staticQueryHashes":[],"slicesMap":{}}