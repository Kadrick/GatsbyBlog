{"componentChunkName":"component---src-layout-post-tsx-content-file-path-src-posts-computer-ps-2-배열돌리기-index-mdx","path":"/post/computer/ps/2/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://kadrick.github.io/GatsbyBlog"}},"mdx":{"body":"\n## 문제집\n\n배열 돌리기 - [https://www.acmicpc.net/workbook/view/6515](https://www.acmicpc.net/workbook/view/6515)\n\n--- \n\n#### 배열 돌리기 1 / 2 - 16926, 16927\n\n껍데기부터 한줄로 뽑아내자.\n\n<CH.Code>\n```cpp 16927.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nvoid extract(const vector<vector<int>> &arr, int h, int w, int r, int c,\n             vector<int> &ret) {\n\n  for (int i = c; i < c + w; i++) {\n    ret.push_back(arr[r][i]);\n  }\n\n  for (int i = r + 1; i < r + h; i++) {\n    ret.push_back(arr[i][c + w - 1]);\n  }\n\n  for (int i = c + w - 2; i >= c; i--) {\n    ret.push_back(arr[r + h - 1][i]);\n  }\n\n  for (int i = r + h - 2; i > r; i--) {\n    ret.push_back(arr[i][c]);\n  }\n\n  return;\n}\n\nvoid load(vector<vector<int>> &arr, int h, int w, int r, int c, int offset,\n          vector<int> &data) {\n\n  int idx = offset;\n  for (int i = c; i < c + w; i++) {\n    arr[r][i] = data[idx];\n    idx = (idx + 1) % data.size();\n  }\n\n  for (int i = r + 1; i < r + h; i++) {\n    arr[i][c + w - 1] = data[idx];\n    idx = (idx + 1) % data.size();\n  }\n\n  for (int i = c + w - 2; i >= c; i--) {\n    arr[r + h - 1][i] = data[idx];\n    idx = (idx + 1) % data.size();\n  }\n\n  for (int i = r + h - 2; i > r; i--) {\n    arr[i][c] = data[idx];\n    idx = (idx + 1) % data.size();\n  }\n\n  return;\n}\n\nint main(void) {\n  fastio;\n\n  int n, m, r;\n  cin >> n >> m >> r;\n\n  vector<vector<int>> arr(n, vector<int>(m, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> arr[i][j];\n    }\n  }\n\n  int l = 0, t = 0, h = n, w = m;\n  while (h > 0 && w > 0) {\n\n    vector<int> data;\n    extract(arr, h, w, t, l, data);\n    load(arr, h, w, t, l, r % data.size(), data);\n\n    l += 1, t += 1;\n    h -= 2, w -= 2;\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cout << arr[i][j] << ' ';\n    }\n    cout << endl;\n  }\n\n  return 0;\n}\n```\n</CH.Code>\n\n---\n\n#### 배열 돌리기 4 - 17406\n\n**회전 연산을 모두 사용해야하고, 순서는 임의로 정해도 된다.** -> 순열을 뽑아내자.\n\n뽑아낸 순열대로 회전하고 값을 구하면 된다.\n\n<Delete>회전 시키는거 잘 구현하자.</Delete>\n\n<CH.Code>\n```cpp 17406.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nvoid print(const vector<vector<int>> &arr) {\n  cout << endl << \"--------------------\" << endl;\n  for (int i = 0; i < arr.size(); i++) {\n    for (int j = 0; j < arr[i].size(); j++) {\n      cout << arr[i][j] << ' ';\n    }\n    cout << endl;\n  }\n  cout << \"--------------------\" << endl;\n}\n\nint value(const vector<vector<int>> &arr) {\n  int ret = INT32_MAX;\n  for (int i = 0; i < arr.size(); i++) {\n    int tmp = 0;\n    for (int j = 0; j < arr[i].size(); j++) {\n      tmp += arr[i][j];\n    }\n    ret = min(ret, tmp);\n  }\n  return ret;\n}\n\nvoid rotateRight(vector<vector<int>> &arr, int n, int m, int ms) {\n  int s = 1;\n  while (s <= ms) {\n    vector<int> tmp;\n\n    for (int i = m - s; i < m + s; i++) {\n      tmp.push_back(arr[n - s][i]);\n    }\n    for (int i = n - s; i < n + s; i++) {\n      tmp.push_back(arr[i][m + s]);\n    }\n    for (int i = m + s; i > m - s; i--) {\n      tmp.push_back(arr[n + s][i]);\n    }\n    for (int i = n + s; i > n - s; i--) {\n      tmp.push_back(arr[i][m - s]);\n    }\n\n    int idx = (-1 + tmp.size()) % tmp.size();\n\n    for (int i = m - s; i < m + s; i++) {\n      arr[n - s][i] = tmp[idx];\n      idx = (idx + 1) % tmp.size();\n    }\n    for (int i = n - s; i < n + s; i++) {\n      arr[i][m + s] = tmp[idx];\n      idx = (idx + 1) % tmp.size();\n    }\n    for (int i = m + s; i > m - s; i--) {\n      arr[n + s][i] = tmp[idx];\n      idx = (idx + 1) % tmp.size();\n    }\n    for (int i = n + s; i > n - s; i--) {\n      arr[i][m - s] = tmp[idx];\n      idx = (idx + 1) % tmp.size();\n    }\n\n    s++;\n  }\n}\n\nint main(void) {\n  fastio;\n\n  int n, m, k;\n  cin >> n >> m >> k;\n\n  vector<vector<int>> arr(n, vector<int>(m, 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      cin >> arr[i][j];\n    }\n  }\n\n  vector<int> batch;\n  vector<tuple<int, int, int>> op;\n  for (int i = 0; i < k; i++) {\n    int r, c, s;\n    cin >> r >> c >> s;\n    op.push_back({r - 1, c - 1, s});\n    batch.push_back(i);\n  }\n\n  int ret = INT32_MAX;\n\n  do {\n\n    auto tmp = arr;\n\n    for (int i = 0; i < k; i++) {\n      auto [r, c, s] = op[batch[i]];\n      rotateRight(tmp, r, c, s);\n      // print(tmp);\n    }\n    ret = min(ret, value(tmp));\n\n  } while (next_permutation(batch.begin(), batch.end()));\n\n  cout << ret << endl;\n\n  return 0;\n}\n```\n</CH.Code>\n\n---\n\n#### 배열 돌리기 3 / 5 - 16935, 17470\n\n5번 6번 연산을 위해 4개의 영역으로 나누고, 해당 영역을 (상,하,좌,우) 4가지 정보로 나타냄\n\n이후, 각 영역의 정보만 바꿔가며 연산을 수행하고, 영역의 정보대로 원본 배열에서 추출해 새로운 정답 배열을 생성함\n\n<CH.Code>\n```cpp 17470.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n    ios::sync_with_stdio(false);                                               \\\n    cin.tie(0);\n#define endl '\\n'\n\nvoid extract(vector<vector<int>> &arr, tuple<int, int, int, int, int> &data,\n             vector<vector<int>> &res) {\n    vector<int> tmp;\n    auto [top, bottom, left, right, f] = data;\n\n    // cout << top << ' ' << bottom << ' ' << left << ' ' << right << endl;\n\n    if (top < bottom) {\n        if (left < right) {\n            // left - top\n            for (int i = top; i <= bottom; i++) {\n                for (int j = left; j <= right; j++) {\n                    tmp.push_back(f ? arr[i][j] : arr[j][i]);\n                }\n                res.push_back(tmp);\n                tmp.resize(0);\n            }\n        } else {\n            // right - top\n            for (int i = top; i <= bottom; i++) {\n                for (int j = left; j >= right; j--) {\n                    tmp.push_back(f ? arr[i][j] : arr[j][i]);\n                }\n                res.push_back(tmp);\n                tmp.resize(0);\n            }\n        }\n    } else {\n        if (left < right) {\n            // left - bottom\n            for (int i = top; i >= bottom; i--) {\n                for (int j = left; j <= right; j++) {\n                    tmp.push_back(f ? arr[i][j] : arr[j][i]);\n                }\n                res.push_back(tmp);\n                tmp.resize(0);\n            }\n        } else {\n            // right - bottom\n            for (int i = top; i >= bottom; i--) {\n                for (int j = left; j >= right; j--) {\n                    tmp.push_back(f ? arr[i][j] : arr[j][i]);\n                }\n                res.push_back(tmp);\n                tmp.resize(0);\n            }\n        }\n    }\n};\n\nvoid render(vector<vector<int>> &arr,\n            vector<tuple<int, int, int, int, int>> &data) {\n    vector<vector<int>> lt, rt, rb, lb;\n\n    extract(arr, data[0], lt);\n    extract(arr, data[1], rt);\n    extract(arr, data[2], rb);\n    extract(arr, data[3], lb);\n\n    for (int i = 0; i < lt.size(); i++) {\n        for (int j = 0; j < rt[0].size(); j++) {\n            lt[i].push_back(rt[i][j]);\n            lb[i].push_back(rb[i][j]);\n        }\n    }\n\n    for (int i = 0; i < lb.size(); i++) {\n        lt.push_back(lb[i]);\n    }\n\n    arr = lt;\n}\n\nvoid meta(vector<vector<int>> &arr,\n          vector<tuple<int, int, int, int, int>> &data) {\n    // left-top\n    data[0] = {0, arr.size() / 2 - 1, 0, arr[0].size() / 2 - 1, true};\n    // right-top\n    data[1] = {0, arr.size() / 2 - 1, arr[0].size() / 2, arr[0].size() - 1,\n               true};\n    // right-bottom\n    data[2] = {arr.size() / 2, arr.size() - 1, arr[0].size() / 2,\n               arr[0].size() - 1, true};\n    // left-bottom\n    data[3] = {arr.size() / 2, arr.size() - 1, 0, arr[0].size() / 2 - 1, true};\n}\n\nvoid work1(vector<tuple<int, int, int, int, int>> &data) {\n    for (int i = 0; i < data.size(); i++) {\n        auto [top, bottom, left, right, f] = data[i];\n        data[i] = {bottom, top, left, right, f};\n    }\n\n    tuple<int, int, int, int, int> tmp = data[0];\n    data[0] = data[3];\n    data[3] = tmp;\n    tmp = data[1];\n    data[1] = data[2];\n    data[2] = tmp;\n}\n\nvoid work2(vector<tuple<int, int, int, int, int>> &data) {\n    for (int i = 0; i < data.size(); i++) {\n        auto [top, bottom, left, right, f] = data[i];\n        data[i] = {top, bottom, right, left, f};\n    }\n    tuple<int, int, int, int, int> tmp = data[0];\n    data[0] = data[1];\n    data[1] = tmp;\n    tmp = data[2];\n    data[2] = data[3];\n    data[3] = tmp;\n}\n\nvoid work3(vector<tuple<int, int, int, int, int>> &data) {\n\n    for (int i = 0; i < data.size(); i++) {\n        auto [top, bottom, left, right, f] = data[i];\n        data[i] = {left, right, bottom, top, !f};\n    }\n\n    vector<tuple<int, int, int, int, int>> res;\n    for (int i = 0; i < 4; i++) {\n        res.push_back(data[(i - 1 + 4) % 4]);\n    }\n    data = res;\n}\n\nvoid work4(vector<tuple<int, int, int, int, int>> &data) {\n\n    for (int i = 0; i < data.size(); i++) {\n        auto [top, bottom, left, right, f] = data[i];\n        data[i] = {right, left, top, bottom, !f};\n    }\n\n    vector<tuple<int, int, int, int, int>> res;\n    for (int i = 0; i < 4; i++) {\n        res.push_back(data[(i + 1) % 4]);\n    }\n    data = res;\n}\n\nvoid work5(vector<tuple<int, int, int, int, int>> &data) {\n    vector<tuple<int, int, int, int, int>> res;\n    for (int i = 0; i < 4; i++) {\n        res.push_back(data[(i - 1 + 4) % 4]);\n    }\n    data = res;\n}\n\nvoid work6(vector<tuple<int, int, int, int, int>> &data) {\n    vector<tuple<int, int, int, int, int>> res;\n    for (int i = 0; i < 4; i++) {\n        res.push_back(data[(i + 1) % 4]);\n    }\n    data = res;\n}\n\nvoid work(vector<vector<int>> &arr, int type,\n          vector<tuple<int, int, int, int, int>> &ctx) {\n\n    switch (type) {\n    case 1:\n        work1(ctx);\n        break;\n    case 2:\n        work2(ctx);\n        break;\n    case 3:\n        work3(ctx);\n        break;\n    case 4:\n        work4(ctx);\n        break;\n    case 5:\n        work5(ctx);\n        break;\n    case 6:\n        work6(ctx);\n        break;\n    }\n}\n\nint main(void) {\n    fastio;\n\n    int n, m, r;\n    cin >> n >> m >> r;\n\n    vector<vector<int>> arr(n, vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> arr[i][j];\n        }\n    }\n\n    vector<int> op(r);\n\n    for (int i = 0; i < r; i++) {\n        cin >> op[i];\n    }\n\n    vector<int> stack, works;\n    // 같은 결과 처리\n    for (int i = 0; i < r; i++) {\n        if (stack.empty()) {\n            stack.push_back(op[i]);\n        } else {\n            if (op[i] <= 2 && stack[stack.size() - 1] == op[i]) {\n                stack.pop_back();\n            } else if (stack.size() >= 3 && op[i] >= 3) {\n\n                bool f = true;\n                // whole\n                for (int j = 0; j < 3; j++) {\n                    f = f && stack[stack.size() - 1 - j] == op[i];\n                }\n                if (f) {\n                    for (int j = 0; j < 3; j++) {\n                        stack.pop_back();\n                    }\n                } else {\n                    stack.push_back(op[i]);\n                }\n\n            } else {\n                stack.push_back(op[i]);\n            }\n        }\n    }\n\n    vector<tuple<int, int, int, int, int>> ctx(4);\n    meta(arr, ctx);\n    for (int i = 0; i < stack.size(); i++) {\n        work(arr, stack[i], ctx);\n    }\n    render(arr, ctx);\n\n    for (int i = 0; i < arr.size(); i++) {\n        for (int j = 0; j < arr[0].size(); j++) {\n            cout << arr[i][j] << ' ';\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```\n</CH.Code>\n\n---\n\n#### 배열 돌리기 6 / 7 - 20327, 20328\n\n8가지의 연산을 각 단계가 가진 4가지 영역(좌상단, 우상단, 우하단, 좌하단)을 **재배치** 하는 연산으로 변형\n    - 1, 2, 3, 4번 연산은 $\\ell$ 값보다 작거나 같은 단계에 적용하는 연산\n    - 5, 6, 7, 8번 연산은 $\\ell$ 값보다 큰 단계에 적용하는 연산\n    - ex) $ 4 \\times 4 $ 배열이 오른쪽 회전한 것은 하위 단계의 $ 4 \\times 4 $ 배열이 하나씩 오른쪽 회전하고, 그것들을 재배치한 것과 같다.\n\n<br/>\n\n그러면 한 번의 연산에 $4^{10}$ 만큼 시간이 걸리는 것은 아닌가?\n    - 하위 모든 영역에 재배치 연산을 하는 것이 아닌, 단계마다 수행해야할 연산을 따로 저장하고, 이후 일괄 적용한다. 그러면 정답을 구할 때만 $4^{10}$ 만큼을 수행하면 된다.\n    - **코드의 Filter 참조**\n\n<CH.Code>\n\n```cpp 20328.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nclass Filter {\npublic:\n  int level;\n  Filter *child;\n  tuple<int, int, int, int> order;\n  Filter(int level) {\n    if (level > 0) {\n      this->level = level;\n      this->child = new Filter(level - 1);\n      this->order = make_tuple(0, 1, 2, 3);\n    }\n  }\n  ~Filter(){};\n\n  void vFlip(int level) {\n    if (this->level >= level) {\n      auto [tl, tr, br, bl] = this->order;\n      this->order = {bl, br, tr, tl};\n    }\n    if (this->level > 1) {\n      child->vFlip(level);\n    }\n  }\n\n  void hFlip(int level) {\n    if (this->level >= level) {\n      auto [tl, tr, br, bl] = this->order;\n      this->order = {tr, tl, bl, br};\n    }\n\n    if (this->level > 1) {\n      child->hFlip(level);\n    }\n  }\n\n  void rRotate(int level) {\n    if (this->level >= level) {\n      auto [tl, tr, br, bl] = this->order;\n      this->order = {bl, tl, tr, br};\n    }\n    if (this->level > 1) {\n      child->rRotate(level);\n    }\n  }\n\n  void lRotate(int level) {\n    if (this->level >= level) {\n      auto [tl, tr, br, bl] = this->order;\n      this->order = {tr, br, bl, tl};\n    }\n\n    if (this->level > 1) {\n      child->lRotate(level);\n    }\n  }\n\n  void vertical(int level) {\n    if (this->level <= level) {\n      auto [tl, tr, br, bl] = this->order;\n      this->order = {bl, br, tr, tl};\n    }\n    if (this->level > 1) {\n      child->vertical(level);\n    }\n  }\n\n  void horizontal(int level) {\n    if (this->level <= level) {\n      auto [tl, tr, br, bl] = this->order;\n      this->order = {tr, tl, bl, br};\n    }\n    if (this->level > 1) {\n      child->horizontal(level);\n    }\n  }\n\n  void right(int level) {\n    if (this->level <= level) {\n      auto [tl, tr, br, bl] = this->order;\n      this->order = {bl, tl, tr, br};\n    }\n    if (this->level > 1) {\n      child->right(level);\n    }\n  }\n\n  void left(int level) {\n    if (this->level <= level) {\n      auto [tl, tr, br, bl] = this->order;\n      this->order = {tr, br, bl, tl};\n    }\n    if (this->level > 1) {\n      child->left(level);\n    }\n  }\n\n  tuple<int, int, int, int> get(int level) {\n    if (this->level == level) {\n      return order;\n    }\n    return this->child->get(level);\n  }\n};\n\nclass Node {\npublic:\n  int level;\n  Node *child[4];\n  pair<int, int> target;\n  Node(int top, int left, int level) {\n    this->level = level;\n    int size = 1 << level;\n    if (level > 0) {\n      child[0] = new Node(top + 0, left + 0, level - 1);\n      child[1] = new Node(top + 0, left + size / 2, level - 1);\n      child[2] = new Node(top + size / 2, left + size / 2, level - 1);\n      child[3] = new Node(top + size / 2, left + 0, level - 1);\n    } else {\n      target = {top, left};\n    }\n  };\n  ~Node(){};\n\n  void print(const vector<vector<int>> &src, vector<vector<int>> &dst,\n             Filter *filter, pair<int, int> pivot) {\n    auto [y, x] = pivot;\n    if (level == 0) {\n      dst[y][x] = src[target.first][target.second];\n    } else {\n      int size = 1 << level;\n      auto [tl, tr, br, bl] = filter->get(this->level);\n      child[tl]->print(src, dst, filter, {y + 0, x + 0});\n      child[tr]->print(src, dst, filter, {y + 0, x + size / 2});\n      child[br]->print(src, dst, filter, {y + size / 2, x + size / 2});\n      child[bl]->print(src, dst, filter, {y + size / 2, x + 0});\n    }\n  }\n};\n\nint main(void) {\n  fastio;\n\n  int n, r;\n  cin >> n >> r;\n\n  vector<vector<int>> arr((1 << n), vector<int>((1 << n), 0)),\n      ans((1 << n), vector<int>((1 << n), 0));\n  for (int i = 0; i < 1 << n; i++) {\n    for (int j = 0; j < 1 << n; j++) {\n      cin >> arr[i][j];\n    }\n  }\n\n  Node *root = new Node(0, 0, n);\n  Filter *filter = new Filter(n);\n\n  for (int i = 0; i < r; i++) {\n    int k, l;\n    cin >> k >> l;\n    switch (k) {\n    case 1:\n      filter->vertical(l);\n      break;\n    case 2:\n      filter->horizontal(l);\n      break;\n    case 3:\n      filter->right(l);\n      break;\n    case 4:\n      filter->left(l);\n      break;\n    case 5:\n      filter->vFlip(l + 1);\n      break;\n    case 6:\n      filter->hFlip(l + 1);\n      break;\n    case 7:\n      filter->rRotate(l + 1);\n      break;\n    case 8:\n      filter->lRotate(l + 1);\n      break;\n    }\n  }\n\n  root->print(arr, ans, filter, {0, 0});\n\n  for (int i = 0; i < ans.size(); i++) {\n    for (int j = 0; j < ans[0].size(); j++) {\n      cout << ans[i][j] << ' ';\n    }\n    cout << endl;\n  }\n\n  return 0;\n}\n```\n\n```go 20328.go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tdebug       = true\n\tinf   int64 = math.MaxInt64\n)\n\n/*========================================================================*/\n/* I/O */\n\nvar (\n\t// scanner = bufio.NewScanner(os.Stdin)\n\t// outF, _ = os.OpenFile(\"out.txt\", os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)\n\t// print   = bufio.NewWriter(outF)\n\n\tscanner = bufio.NewScanner(os.Stdin)\n\tprint   = bufio.NewWriter(os.Stdout)\n)\n\nfunc nextInt() int64 {\n\tscanner.Scan()\n\ttext := scanner.Text()\n\tv, _ := strconv.ParseInt(text, 10, 64)\n\treturn v\n}\n\nfunc nextString() string {\n\tscanner.Scan()\n\ttext := scanner.Text()\n\treturn text\n}\n\n/*========================================================================*/\n\ntype Filter struct {\n\tlv    int\n\torder []int\n\tchild *Filter\n}\n\nfunc NewFilter(lv int) *Filter {\n\tif lv > 0 {\n\t\tret := &Filter{\n\t\t\tlv:    lv,\n\t\t\torder: []int{0, 1, 2, 3},\n\t\t\tchild: NewFilter(lv - 1),\n\t\t}\n\t\treturn ret\n\t}\n\treturn nil\n}\n\nfunc (this *Filter) vFlip(level int) {\n\tif this.lv >= level {\n\t\ttmp := this.order\n\t\tthis.order = []int{tmp[3], tmp[2], tmp[1], tmp[0]}\n\t}\n\tif this.lv > 1 {\n\t\tthis.child.vFlip(level)\n\t}\n}\n\nfunc (this *Filter) hFlip(level int) {\n\tif this.lv >= level {\n\t\ttmp := this.order\n\t\tthis.order = []int{tmp[1], tmp[0], tmp[3], tmp[2]}\n\t}\n\tif this.lv > 1 {\n\t\tthis.child.hFlip(level)\n\t}\n}\n\nfunc (this *Filter) rRotate(level int) {\n\tif this.lv >= level {\n\t\ttmp := this.order\n\t\tthis.order = []int{tmp[3], tmp[0], tmp[1], tmp[2]}\n\t}\n\tif this.lv > 1 {\n\t\tthis.child.rRotate(level)\n\t}\n}\n\nfunc (this *Filter) lRotate(level int) {\n\tif this.lv >= level {\n\t\ttmp := this.order\n\t\tthis.order = []int{tmp[1], tmp[2], tmp[3], tmp[0]}\n\t}\n\tif this.lv > 1 {\n\t\tthis.child.lRotate(level)\n\t}\n}\n\nfunc (this *Filter) vertical(level int) {\n\tif this.lv <= level {\n\t\ttmp := this.order\n\t\tthis.order = []int{tmp[3], tmp[2], tmp[1], tmp[0]}\n\t}\n\tif this.lv > 1 {\n\t\tthis.child.vertical(level)\n\t}\n}\n\nfunc (this *Filter) horizontal(level int) {\n\tif this.lv <= level {\n\t\ttmp := this.order\n\t\tthis.order = []int{tmp[1], tmp[0], tmp[3], tmp[2]}\n\t}\n\tif this.lv > 1 {\n\t\tthis.child.horizontal(level)\n\t}\n}\n\nfunc (this *Filter) right(level int) {\n\tif this.lv <= level {\n\t\ttmp := this.order\n\t\tthis.order = []int{tmp[3], tmp[0], tmp[1], tmp[2]}\n\t}\n\tif this.lv > 1 {\n\t\tthis.child.right(level)\n\t}\n}\n\nfunc (this *Filter) left(level int) {\n\tif this.lv <= level {\n\t\ttmp := this.order\n\t\tthis.order = []int{tmp[1], tmp[2], tmp[3], tmp[0]}\n\t}\n\tif this.lv > 1 {\n\t\tthis.child.left(level)\n\t}\n}\n\nfunc (this *Filter) get(level int) []int {\n\tif this.lv == level {\n\t\treturn this.order\n\t}\n\treturn this.child.get(level)\n}\n\n/*========================================================================*/\n\ntype Renderer struct {\n\tlv    int\n\tchild []*Renderer\n\ty, x  int\n}\n\nfunc NewRenderer(y, x, lv int) *Renderer {\n\tret := &Renderer{\n\t\tlv:    lv,\n\t\tchild: nil,\n\t}\n\n\tif lv > 0 {\n\t\tsize := 1 << lv\n\t\tret.child = make([]*Renderer, 4)\n\t\tret.child[0] = NewRenderer(y+0, x+0, lv-1)\n\t\tret.child[1] = NewRenderer(y+0, x+size/2, lv-1)\n\t\tret.child[2] = NewRenderer(y+size/2, x+size/2, lv-1)\n\t\tret.child[3] = NewRenderer(y+size/2, x+0, lv-1)\n\t} else {\n\t\tret.y, ret.x = y, x\n\t}\n\n\treturn ret\n}\n\nfunc (this *Renderer) render(src, dst [][]int, filter *Filter, y, x int) {\n\tif this.lv == 0 {\n\t\tdst[y][x] = src[this.y][this.x]\n\t} else {\n\t\tsize := 1 << this.lv\n\t\torder := filter.get(this.lv)\n\t\tthis.child[order[0]].render(src, dst, filter, y+0, x+0)\n\t\tthis.child[order[1]].render(src, dst, filter, y+0, x+size/2)\n\t\tthis.child[order[2]].render(src, dst, filter, y+size/2, x+size/2)\n\t\tthis.child[order[3]].render(src, dst, filter, y+size/2, x+0)\n\t}\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\tdefer print.Flush()\n\n\tn, r := nextInt(), nextInt()\n\n\tarr, ans := make([][]int, 1<<n), make([][]int, 1<<n)\n\tfor i := 0; i < 1<<n; i++ {\n\t\tarr[i] = make([]int, 1<<n)\n\t\tans[i] = make([]int, 1<<n)\n\t\tfor j := 0; j < 1<<n; j++ {\n\t\t\tarr[i][j] = int(nextInt())\n\t\t}\n\t}\n\n\tfilter := NewFilter(int(n))\n\n\tfor i := 0; i < int(r); i++ {\n\t\tk, l := int(nextInt()), int(nextInt())\n\n\t\tswitch k {\n\t\tcase 1:\n\t\t\tfilter.vertical(l)\n\t\tcase 2:\n\t\t\tfilter.horizontal(l)\n\t\tcase 3:\n\t\t\tfilter.right(l)\n\t\tcase 4:\n\t\t\tfilter.left(l)\n\t\tcase 5:\n\t\t\tfilter.vFlip(l + 1)\n\t\tcase 6:\n\t\t\tfilter.hFlip(l + 1)\n\t\tcase 7:\n\t\t\tfilter.rRotate(l + 1)\n\t\tcase 8:\n\t\t\tfilter.lRotate(l + 1)\n\t\t}\n\t}\n\n\trenderer := NewRenderer(0, 0, int(n))\n\trenderer.render(arr, ans, filter, 0, 0)\n\n\tfor i := 0; i < 1<<n; i++ {\n\t\tfor j := 0; j < 1<<n; j++ {\n\t\t\tfmt.Fprintf(print, \"%d \", ans[i][j])\n\t\t}\n\t\tfmt.Fprintf(print, \"\\n\")\n\t}\n\n}\n```\n\n</CH.Code>\n","frontmatter":{"title":"PS Note #2 - 배열 돌리기","tags":["Problem Solving"],"description":"빙글빙글 돌아가는 참피의 하루","slug":"computer/ps/2","date":"2024-07-18"}}},"pageContext":{"id":"61533b0a-c0f5-5b78-95c3-0f15612f5e80","frontmatter":{"title":"PS Note #2 - 배열 돌리기","tags":["Problem Solving"],"date":"2024-07-18T00:00:00.000Z","description":"빙글빙글 돌아가는 참피의 하루","slug":"computer/ps/2"}}},"staticQueryHashes":[],"slicesMap":{}}