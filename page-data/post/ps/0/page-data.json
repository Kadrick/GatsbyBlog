{"componentChunkName":"component---src-layout-post-tsx-content-file-path-src-posts-ps-0-index-mdx","path":"/post/ps/0/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://kadrick.github.io/GatsbyBlog"}},"mdx":{"body":"\nimport {\n  Table,\n  TableCaption,\n  TableContainer,\n  Thead,\n  Tbody,\n  Tr,\n  Th,\n  Td,\n} from \"@chakra-ui/react\";\n\n## 문제집\n\n한국정보올림피아드 시.도 지역본선 2004 - [https://www.acmicpc.net/category/74](https://www.acmicpc.net/category/74)\n\n### 초등부\n\n---\n\n#### 1. 일곱 난쟁이 - 2309\n\n9개의 수를 모두 더하고, 2개씩 빼서 정답을 찾았다.\n\n#### 2. 줄 세우기 - 2605\n\n그냥 지정된 위치에 잘 넣으면 된다.\n\n#### 3. 바이러스 - 2606\n\n그래프 탐색 중 방문하는 노드의 개수를 세보자.\n\n#### 4. 비슷한 단어 - 2607\n\n두 문자열의 구성을 비교해서 서로 다른 구성이 2개 이하면 비슷하다고 판단했다.\n\n#### 5. 로마 숫자 - 2608\n\n구현을 잘하자.\n\n<CH.Code>\n\n```cpp 2309.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint arr[9], sum, flag;\n\nvoid print(int no1, int no2) {\n  for (int i = 0; i < 9; ++i) {\n    if(i == no1 || no2 == i) continue;\n    cout << arr[i] << endl;\n  }\n}\n\nint main(void) {\n  fastio;\n\n  for (int i = 0; i < 9; ++i) {\n    cin >> arr[i];\n    sum += arr[i];\n  }\n\n  sort(arr, arr + 9);\n\n  for (int i = 0;  i < 9; ++i) {\n    sum -= arr[i];\n    for (int j = 0; j < 9; ++j) {\n      if(i != j && sum - arr[j] == 100) {\n        flag = 1;\n        print(i, j);\n      }\n    }\n    if(flag) break;\n    sum += arr[i];\n  }\n\n  return 0;\n}\n```\n\n```go 2605.go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tdebug       = true\n\tinf   int64 = math.MaxInt64\n)\n\n/*========================================================================*/\n/* I/O */\n\nvar (\n\t// scanner = bufio.NewScanner(os.Stdin)\n\t// outF, _ = os.OpenFile(\"out.txt\", os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)\n\t// print   = bufio.NewWriter(outF)\n\n\tscanner = bufio.NewScanner(os.Stdin)\n\tprint   = bufio.NewWriter(os.Stdout)\n)\n\nfunc nextInt() int64 {\n\tscanner.Scan()\n\ttext := scanner.Text()\n\tv, _ := strconv.ParseInt(text, 10, 64)\n\treturn v\n}\n\nfunc nextString() string {\n\tscanner.Scan()\n\ttext := scanner.Text()\n\treturn text\n}\n\n/*========================================================================*/\n\nfunc min(a, b int64) int64 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\tdefer print.Flush()\n\n\tn := nextInt()\n\n\tarr := make([]int64, n)\n\tfor i := 0; i < int(n); i++ {\n\t\tarr[i] = nextInt()\n\t}\n\n\tans := []int64{1}\n\tfor i := 1; i < int(n); i++ {\n\t\tif arr[i] == int64(len(ans)) {\n\t\t\tans = append([]int64{int64(i + 1)}, ans...)\n\t\t} else if arr[i] == 0 {\n\t\t\tans = append(ans, int64(i+1))\n\t\t} else {\n\t\t\tpivot := len(ans) - int(arr[i])\n\t\t\tans = append(ans[:pivot], append([]int64{int64(i + 1)}, ans[pivot:]...)...)\n\t\t}\n\t}\n\n\tfor i := 0; i < int(n); i++ {\n\t\tfmt.Fprintf(print, \"%d \", ans[i])\n\t}\n\n}\n```\n\n```cpp 2606.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint nTotalComputer;\nint nEdge;\nint ans;\nbool adjTable[101][101];\nbool isVisited[101];\n\nvoid dfs(int computer) {\n  ans++;\n  isVisited[computer] = true;\n  for (int i = 1; i <= nTotalComputer; ++i) {\n    if (adjTable[computer][i] && !isVisited[i]) {\n      dfs(i);\n    }\n  }\n}\n\nint main(void) {\n  fastio;\n\n  cin >> nTotalComputer;\n  cin >> nEdge;\n\n  for (int i = 0; i < nEdge; ++i) {\n    int u, v;\n    cin >> u >> v;\n    adjTable[u][v] = true;\n    adjTable[v][u] = true;\n  }\n\n  dfs(1);\n\n  cout << ans - 1 << endl;\n\n  return 0;\n}\n```\n\n```go 2607.go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tdebug       = true\n\tinf   int64 = math.MaxInt64\n)\n\n/*========================================================================*/\n/* I/O */\n\nvar (\n\t// scanner = bufio.NewScanner(os.Stdin)\n\t// outF, _ = os.OpenFile(\"out.txt\", os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)\n\t// print   = bufio.NewWriter(outF)\n\n\tscanner = bufio.NewScanner(os.Stdin)\n\tprint   = bufio.NewWriter(os.Stdout)\n)\n\nfunc nextInt() int64 {\n\tscanner.Scan()\n\ttext := scanner.Text()\n\tv, _ := strconv.ParseInt(text, 10, 64)\n\treturn v\n}\n\nfunc nextString() string {\n\tscanner.Scan()\n\ttext := scanner.Text()\n\treturn text\n}\n\n/*========================================================================*/\n\nfunc min(a, b int64) int64 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\tdefer print.Flush()\n\n\tn, str := nextInt(), nextString()\n\n\tans := 0\n\n\tstandard := make([]int, 26)\n\tfor i := 0; i < len(str); i++ {\n\t\tstandard[byte(str[i])-byte('A')]++\n\t}\n\n\tfor i := 0; i < int(n-1); i++ {\n\n\t\ttarget := nextString()\n\n\t\tif int(math.Abs(float64(len(target)-len(str)))) >= 2 {\n\t\t\tcontinue\n\t\t}\n\n\t\tcompare := make([]int, 26)\n\t\tfor i := 0; i < len(target); i++ {\n\t\t\tcompare[byte(target[i])-byte('A')]++\n\t\t}\n\n\t\tanomaly := 0\n\n\t\tfor j := 0; j < 26; j++ {\n\t\t\tif standard[j] != compare[j] {\n\t\t\t\tanomaly += int(math.Abs(float64(standard[j] - compare[j])))\n\t\t\t}\n\t\t}\n\n\t\tif anomaly <= 2 {\n\t\t\tans++\n\t\t}\n\n\t}\n\n\tfmt.Fprintf(print, \"%d\\n\", ans)\n\n}\n```\n\n```go 2608.go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst (\n\tdebug       = true\n\tinf   int64 = math.MaxInt64\n)\n\n/*========================================================================*/\n/* I/O */\n\nvar (\n\t// scanner = bufio.NewScanner(os.Stdin)\n\t// outF, _ = os.OpenFile(\"out.txt\", os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)\n\t// print   = bufio.NewWriter(outF)\n\n\tscanner = bufio.NewScanner(os.Stdin)\n\tprint   = bufio.NewWriter(os.Stdout)\n)\n\nfunc nextInt() int64 {\n\tscanner.Scan()\n\ttext := scanner.Text()\n\tv, _ := strconv.ParseInt(text, 10, 64)\n\treturn v\n}\n\nfunc nextString() string {\n\tscanner.Scan()\n\ttext := scanner.Text()\n\treturn text\n}\n\n/*========================================================================*/\n\nfunc min(a, b int64) int64 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc charToInt(t byte) int {\n\tswitch t {\n\tcase byte('I'):\n\t\treturn 1\n\tcase byte('V'):\n\t\treturn 5\n\tcase byte('X'):\n\t\treturn 10\n\tcase byte('L'):\n\t\treturn 50\n\tcase byte('C'):\n\t\treturn 100\n\tcase byte('D'):\n\t\treturn 500\n\tcase byte('M'):\n\t\treturn 1000\n\t}\n\treturn -1\n}\n\nfunc intToChar(t int) string {\n\tswitch t {\n\tcase 1000:\n\t\treturn \"M\"\n\tcase 900:\n\t\treturn \"CM\"\n\tcase 500:\n\t\treturn \"D\"\n\tcase 400:\n\t\treturn \"CD\"\n\tcase 100:\n\t\treturn \"C\"\n\tcase 90:\n\t\treturn \"XC\"\n\tcase 50:\n\t\treturn \"L\"\n\tcase 40:\n\t\treturn \"XL\"\n\tcase 10:\n\t\treturn \"X\"\n\tcase 9:\n\t\treturn \"IX\"\n\tcase 5:\n\t\treturn \"V\"\n\tcase 4:\n\t\treturn \"IV\"\n\tcase 1:\n\t\treturn \"I\"\n\t}\n\treturn \"\"\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\tdefer print.Flush()\n\n\ta, b := []byte(nextString()), []byte(nextString())\n\taVal, bVal := 0, 0\n\n\tfor i := 0; i < len(a); i++ {\n\t\tif i != len(a)-1 && charToInt(a[i]) < charToInt(a[i+1]) {\n\t\t\taVal += charToInt(a[i+1]) - charToInt(a[i])\n\t\t\ti++\n\t\t} else {\n\t\t\taVal += charToInt(a[i])\n\t\t}\n\t}\n\n\tfor i := 0; i < len(b); i++ {\n\t\tif i != len(b)-1 && charToInt(b[i]) < charToInt(b[i+1]) {\n\t\t\tbVal += charToInt(b[i+1]) - charToInt(b[i])\n\t\t\ti++\n\t\t} else {\n\t\t\tbVal += charToInt(b[i])\n\t\t}\n\t}\n\n\tans := aVal + bVal\n\tfmt.Fprintf(print, \"%d\\n\", ans)\n\n\tdigit := []int{ans / 1000,\n\t\t(ans % 1000) / 100,\n\t\t(ans % 100) / 10,\n\t\tans % 10,\n\t}\n\n\tansStr := \"\"\n\n\tfor i := 0; i < 4; i++ {\n\t\tif digit[i] == 4 || digit[i] == 9 {\n\t\t\tansStr += intToChar(digit[i] * int(math.Pow10(3-i)))\n\t\t\tcontinue\n\t\t} else if digit[i] >= 5 {\n\t\t\tansStr += intToChar(5 * int(math.Pow10(3-i)))\n\t\t\tdigit[i] -= 5\n\t\t}\n\n\t\tfor j := 0; j < digit[i]; j++ {\n\t\t\tansStr += intToChar(int(math.Pow10(3 - i)))\n\t\t}\n\t}\n\n\tfmt.Fprintf(print, \"%s\\n\", ansStr)\n\n}\n```\n\n</CH.Code>\n\n### 중등부\n\n---\n\n#### 1. 최대공약수와 최소공배수 - 2609\n\nGCD 구하기\n\n#### 2. 비슷한 단어 - 2607\n\n초등부 4번과 동일\n\n#### 3. 회의준비 - 2610\n\n1. 분리 집합으로 팀을 나눈다.\n2. 각 정점에서 다른 정점으로의 거리를 계산한다. (100명 이하니까 $n^3$이 가능하다.)\n3. 팀에서 다른 팀원까지의 거리의 최댓값이 최소가 되는 대표를 정한다.\n4. 선출된 대표를 정렬한다.\n\n#### 4. 자동차 경주 - 2611\n\nDAG에서 최대거리를 구하자. -> 위상정렬\n\n정렬이 이루어질 때, 거리가 최대가 되는 간선을 저장하자. 그리고, 역추적도 필요하다.\n\n#### 5. DNA 유사도 - 2612\n\n문제에서 공백을 적절히 넣는 행위는 `s1` 문자열에서 편집(교체, 삽입, 삭제)를 통해서 `s2`를 만드는 것이라고 생각할 수 있다.\n다음 표를 확인해보자.\n\n<TableContainer>\n  <Table variant=\"simple\">\n    <TableCaption>*은 공백이다.</TableCaption>\n    <Thead>\n      <Tr>\n        <Th>identifier</Th>\n        <Th>string</Th>\n        <Th>act</Th>\n      </Tr>\n    </Thead>\n    <Tbody>\n      <Tr>\n        <Td>s1</Td>\n        <Td>A T * => AT</Td>\n        <Td rowspan=\"2\">교체</Td>\n      </Tr>\n      <Tr>\n        <Td>s2</Td>\n        <Td>A * G => AG</Td>\n      </Tr>\n      <Tr>\n        <Td>s1</Td>\n        <Td>A G * => AG</Td>\n        <Td rowspan=\"2\">삽입</Td>\n      </Tr>\n      <Tr>\n        <Td>s2</Td>\n        <Td>A G T => AGT</Td>\n      </Tr>\n      <Tr>\n        <Td>s1</Td>\n        <Td>A G T => AGT</Td>\n        <Td rowspan=\"2\">삭제</Td>\n      </Tr>\n      <Tr>\n        <Td>s2</Td>\n        <Td>A G * => AG</Td>\n      </Tr>\n    </Tbody>\n  </Table>\n</TableContainer>\n\n이걸 생각하고 문제를 보면, [편집 거리 구하기](https://en.wikipedia.org/wiki/Edit_distance) + 역추적 문제임을 알 수 있다.\n\n<CH.Code>\n\n```cpp 2609.cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#define endl    '\\n'\n#define FastIO ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef tuple<int, int, int> tiii;\n\nint g;\n\nint gcd(int a, int b)\n{\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\n\nint main(void)\n{\n\tFastIO;\n\n\tint a, b;\n\tcin >> a >> b;\n\n\tg = gcd(a, b);\n\tcout << g << endl;\n\tcout << a * b / g << endl;\n\n\treturn 0;\n}\n```\n\n```go 2610.go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nconst (\n\tdebug       = true\n\tinf   int64 = math.MaxInt64\n)\n\n/*========================================================================*/\n/* I/O */\n\nvar (\n\t// scanner = bufio.NewScanner(os.Stdin)\n\t// outF, _ = os.OpenFile(\"out.txt\", os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)\n\t// print   = bufio.NewWriter(outF)\n\n\tscanner = bufio.NewScanner(os.Stdin)\n\tprint   = bufio.NewWriter(os.Stdout)\n)\n\nfunc nextInt() int64 {\n\tscanner.Scan()\n\ttext := scanner.Text()\n\tv, _ := strconv.ParseInt(text, 10, 64)\n\treturn v\n}\n\nfunc nextString() string {\n\tscanner.Scan()\n\ttext := scanner.Text()\n\treturn text\n}\n\n/*========================================================================*/\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc find(arr []int, x int) int {\n\tif arr[x] == x {\n\t\treturn x\n\t}\n\tarr[x] = find(arr, arr[x])\n\treturn arr[x]\n}\n\nfunc merge(arr []int, u, v int) {\n\tu = find(arr, u)\n\tv = find(arr, v)\n\n\tif u != v {\n\t\tarr[max(u, v)] = min(u, v)\n\t}\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\tdefer print.Flush()\n\n\tn, m := nextInt(), nextInt()\n\n\tset := []int{0}\n\tfor i := 0; i < int(n); i++ {\n\t\tset = append(set, i+1)\n\t}\n\n\tdist := make([][]int, n+1)\n\tfor i := 0; i <= int(n); i++ {\n\t\tfor j := 0; j <= int(n); j++ {\n\t\t\tif i == j {\n\t\t\t\tdist[i] = append(dist[i], 0)\n\t\t\t} else {\n\t\t\t\tdist[i] = append(dist[i], math.MaxInt32)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i := 0; i < int(m); i++ {\n\t\tu, v := nextInt(), nextInt()\n\t\tmerge(set, int(u), int(v))\n\t\tdist[u][v] = 1\n\t\tdist[v][u] = 1\n\t}\n\n\tfor k := 1; k <= int(n); k++ {\n\t\tfor i := 1; i <= int(n); i++ {\n\t\t\tfor j := 1; j <= int(n); j++ {\n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])\n\t\t\t}\n\t\t}\n\t}\n\n\tteams := map[int][]int{}\n\n\tfor i := 0; i < int(n); i++ {\n\t\tfind(set, i+1)\n\t\tteam, ok := teams[set[i+1]]\n\t\tif !ok {\n\t\t\tteams[set[i+1]] = make([]int, 0)\n\t\t\tteam = teams[set[i+1]]\n\t\t}\n\t\tteam = append(team, i+1)\n\t\tteams[set[i+1]] = team\n\t}\n\n\tfmt.Fprintf(print, \"%d\\n\", len(teams))\n\n\tansMem := []int{}\n\tfor _, team := range teams {\n\n\t\tleader := math.MaxInt32\n\t\tleaderVal := math.MaxInt32\n\n\t\tfor _, member := range team {\n\n\t\t\tfactor := 0\n\t\t\tfor i := 0; i < int(n); i++ {\n\t\t\t\tif dist[member][i+1] != math.MaxInt32 {\n\t\t\t\t\tfactor = max(factor, dist[member][i+1])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif factor < leaderVal {\n\t\t\t\tleader = member\n\t\t\t\tleaderVal = factor\n\t\t\t}\n\n\t\t}\n\n\t\tansMem = append(ansMem, leader)\n\n\t}\n\n\tsort.Slice(ansMem, func(i, j int) bool {\n\t\treturn ansMem[i] < ansMem[j]\n\t})\n\n\tfor _, member := range ansMem {\n\t\tfmt.Fprintf(print, \"%d\\n\", member)\n\t}\n}\n\n```\n\n```cpp 2611.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nint main(void) {\n  fastio;\n\n  int n, m;\n  cin >> n >> m;\n\n  vector<pair<int, int>> dist(n + 1, {-1, -1});\n  vector<int> inDeg(n + 1, 0);\n  vector<vector<pair<int, int>>> graph(n + 1, vector<pair<int, int>>(0));\n\n  for (int i = 0; i < m; i++) {\n    int p, q, r;\n    cin >> p >> q >> r;\n    graph[p].push_back({(q == 1 ? 0 : q), r});\n    inDeg[(q == 1 ? 0 : q)]++;\n  }\n\n  dist[1] = {0, -1};\n  queue<pair<int, int>> q;\n  q.push({1, 0});\n\n  while (!q.empty()) {\n    auto [cur, total] = q.front();\n    q.pop();\n\n    for (auto [next, cost] : graph[cur]) {\n      inDeg[next]--;\n\n      if (dist[next].first < total + cost) {\n        dist[next] = {total + cost, cur};\n      }\n\n      if (!inDeg[next]) {\n        q.push({next, dist[next].first});\n      }\n    }\n  }\n\n  cout << dist[0].first << endl;\n\n  vector<int> route;\n\n  int cur = 0;\n  while (cur != 1) {\n    route.push_back(dist[cur].second);\n    cur = dist[cur].second;\n  }\n\n  for (int i = route.size() - 1; i >= 0; i--) {\n    cout << route[i] << ' ';\n  }\n  cout << 1 << endl;\n\n  return 0;\n}\n```\n\n```cpp 2612.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\nenum Type { SAME, INSERT, DELETE, REPLACE };\n\nint main(void) {\n  fastio;\n\n  int len1, len2;\n  string s1, s2;\n  cin >> len1 >> s1 >> len2 >> s2;\n\n  vector<vector<pair<int, int>>> usado(\n      len1 + 1, vector<pair<int, int>>(len2 + 1, {0, -1}));\n\n  for (int i = 1; i <= len1; i++) {\n    usado[i][0].first = usado[i - 1][0].first - 2;\n  }\n\n  for (int i = 1; i <= len2; i++) {\n    usado[0][i].first = usado[0][i - 1].first - 2;\n  }\n\n  pair<int, pair<int, int>> top = {INT_MIN, {0, 0}};\n\n  for (int i = 1; i <= len1; i++) {   // s1\n    for (int j = 1; j <= len2; j++) { // s2\n\n      if (s1[i - 1] == s2[j - 1]) {\n        usado[i][j] = {max(0, usado[i - 1][j - 1].first) + 3, SAME};\n      } else {\n        int val = max({\n            usado[i - 1][j].first - 2,\n            usado[i][j - 1].first - 2,\n            usado[i - 1][j - 1].first - 2,\n        });\n\n        if (val == usado[i - 1][j].first - 2) {\n          usado[i][j] = {val, DELETE};\n        } else if (val == usado[i][j - 1].first - 2) {\n          usado[i][j] = {val, INSERT};\n        } else if (val == usado[i - 1][j - 1].first - 2) {\n          usado[i][j] = {val, REPLACE};\n        }\n      }\n\n      if (top.first < usado[i][j].first && usado[i][j].second == SAME) {\n        top = {usado[i][j].first, {i, j}};\n      }\n    }\n  }\n\n  pair<int, pair<int, int>> cur = top;\n  vector<pair<int, int>> trace;\n  trace.push_back({0, 0});\n\n  do {\n\n    auto [val, pos] = cur;\n    auto [y, x] = pos;\n\n    switch (usado[y][x].second) {\n    case SAME:\n      trace.push_back({-1, -1});\n      cur = {usado[y - 1][x - 1].first, {y - 1, x - 1}};\n      break;\n    case INSERT:\n      trace.push_back({0, -1});\n      cur = {usado[y][x - 1].first, {y, x - 1}};\n      break;\n    case DELETE:\n      trace.push_back({-1, 0});\n      cur = {usado[y - 1][x].first, {y - 1, x}};\n      break;\n    case REPLACE:\n      trace.push_back({-1, -1});\n      cur = {usado[y - 1][x - 1].first, {y - 1, x - 1}};\n      break;\n    }\n  } while (cur.first > 0 &&\n           usado[cur.second.first][cur.second.second].second != -1);\n\n  cout << top.first << endl;\n\n  string ans1 = \"\", ans2 = \"\";\n  pair<int, int> pos = top.second;\n  for (auto [dy, dx] : trace) {\n    if (dy != 0) {\n      ans1 = s1[pos.first - 1] + ans1;\n      pos.first += dy;\n    }\n    if (dx != 0) {\n      ans2 = s2[pos.second - 1] + ans2;\n      pos.second += dx;\n    }\n  }\n\n  cout << ans1 << endl << ans2 << endl;\n\n  return 0;\n}\n```\n\n</CH.Code>\n\n### 고등부\n\n---\n\n#### 1. 최대공약수와 최소공배수 - 2609\n\n중등부 1번\n\n#### 2. 로마 숫자 - 2608\n\n초등부 5번\n\n#### 2. 회의 준비 - 2610\n\n중등부 3번\n\n#### 4. 숫자구슬 - 2613\n\n모든 1~n 번까지의 누적합을 미리 구하고, 구간을 잘라보자. $dp[현재 그룹 번호][시작 구슬 번호]$\n\n#### 5. 청개구리 - 2614\n\n뭔가 개구리 뛰는걸로 방정식 세워서? 계수 장난하는 것 같은데, 식 세우기를 못하겠다.\n\n<Delete>(진짜 어케 푸는거임? 정답률도 곱창 났던데...)</Delete>\n\n<CH.Code>\n\n```cpp 2613.cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fastio                                                                 \\\n  ios::sync_with_stdio(false);                                                 \\\n  cin.tie(0);\n#define endl '\\n'\n\n// [start, end]\nint get(vector<int> &sum, int start, int end) {\n  return sum[end] - sum[start - 1];\n}\n\nint solve(vector<vector<int>> &trace, vector<vector<int>> &cache,\n          vector<int> &sum, int cur, int offset, int mxGroup) {\n\n  if (cache[cur][offset] != -1) {\n    return cache[cur][offset];\n  }\n\n  if (cur == mxGroup) {\n    trace[cur][offset] = sum.size() - 1;\n    cache[cur][offset] = get(sum, offset, sum.size() - 1);\n    return cache[cur][offset];\n  }\n\n  int ret = INT32_MAX;\n\n  int end = sum.size() - 1 - (mxGroup - cur);\n\n  for (int i = offset; i <= end; i++) {\n\n    int chk = max(get(sum, offset, i),\n                  solve(trace, cache, sum, cur + 1, i + 1, mxGroup));\n\n    if (ret > chk) {\n      trace[cur][offset] = i;\n      ret = chk;\n    }\n  }\n\n  cache[cur][offset] = ret;\n  return ret;\n}\n\nint main(void) {\n  fastio;\n\n  int n, m;\n  cin >> n >> m;\n\n  vector<int> arr(n + 1, 0), sum(n + 1, 0);\n  for (int i = 0; i < n; i++) {\n    cin >> arr[i + 1];\n    sum[i + 1] = arr[i + 1] + sum[i];\n  }\n\n  vector<vector<int>> cache(m + 1, vector<int>(n + 1, -1));\n  vector<vector<int>> trace(m + 1, vector<int>(n + 1, 0));\n\n  cout << solve(trace, cache, sum, 1, 1, m) << endl;\n\n  int offset = 1, before = 0;\n  for (int i = 0; i < m; i++) {\n    cout << trace[i + 1][offset] - before << ' ';\n    before = trace[i + 1][offset];\n    offset = trace[i + 1][offset] + 1;\n  }\n\n  return 0;\n}\n```\n\n</CH.Code>\n","frontmatter":{"title":"PS Note #0","tags":["Problem Solving"],"description":"한국정보올림피아드 시.도 지역본선 2004","slug":"ps/0","date":"2024-06-16"}}},"pageContext":{"id":"e2b82e22-7043-5c03-ab39-4431797b6c77","frontmatter":{"title":"PS Note #0","tags":["Problem Solving"],"date":"2024-06-16T00:00:00.000Z","description":"한국정보올림피아드 시.도 지역본선 2004","slug":"ps/0"}}},"staticQueryHashes":[],"slicesMap":{}}